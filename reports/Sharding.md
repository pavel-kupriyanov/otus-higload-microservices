# Отчет по заданию 4 (Шардинг)

## Реализация

Шардинг реализован по принципу **умный клиент** - логика шардирования находится в приложении.  

Основная причина — интереснее попробовать сделать самому, чем просто сконфигурировать готовое решение.

В главной базе данных созданы 2 таблицы:

#### database_info
```sql
CREATE TABLE database_info (
  id int NOT NULL AUTO_INCREMENT,
  host varchar(255) NOT NULL,
  port int NOT NULL,
  user varchar(255) NOT NULL,
  password varchar(255) NOT NULL,
  name varchar(255) NOT NULL,
  PRIMARY KEY (id)
)
```

#### shards_info

```sql
CREATE TABLE shards_info (
  id int NOT NULL AUTO_INCREMENT,
  db_info int NOT NULL,
  shard_table varchar(255) NOT NULL,
  shard_key int NOT NULL,
  state varchar(255) NOT NULL,
  PRIMARY KEY (id),
  UNIQUE KEY unique_key_per_table (shard_table,shard_key),
  KEY db_info (db_info),
  CONSTRAINT shards_info_ibfk_1 FOREIGN KEY (db_info) REFERENCES database_info (id)
)
```

На хостах, указанных как шарды таблицы `messages` создана эта таблица:

#### messages

```sql
CREATE TABLE messages (
  id varchar(36) NOT NULL,
  chat_key varchar(255) NOT NULL,
  author_id int NOT NULL,
  text text NOT NULL,
  created timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (id),
  KEY chat (chat_key,created)
)
```

В качестве ключа шардинга был выбран `chat_key` - идентификатор чата, формируется по принципу:

```
user_ids = [user1.id, user2.id]
key = f'{min(user_ids)}:{max(user_ids)}'
```

Это не полностью решает проблему с эффектом "Леди Гаги" (теоретически возможно, что один чат слишком разрастется),
но, по моему мнению, этот кейс менее вероятен, а взамен мы уверены, что весь чат находится на одном сервере, что
облегчает доступ к данным.

Когда пользователь запрашивает сообщения из чата или создает новое сообщение из таблицы `shards_info` получаются
список подходящих шардов, хеш от `chat_key` остатком от деления отображается на нужный шард.

Недостаток этой схемы заключается в не обходимости выполнять отдельный запрос к таблице шардов,
который не может быть закеширован на стороне приложения (см. **Решардинг** ниже).
В реальном приложении лучше использовать Redis или другое резидентное хранилище для ускорения этого запроса.

Реализация доступна в файле:

[Базовый класс](../social_network/db/sharding/base.py)

## Решардинг

Для того, чтобы переносить только половину данных при решарде число серверов всегда должно быть степенью двойки.
Это позволит, в случае добавления или удаления серверов переносить только половину данных.

### Решардинг без даунтайма

(Этот функционал не реализован в рамках задания, но учтен при проектировании)

В таблице с информацией о шардах служебное поле `state` означает готовность сервера для работы.

Состояния:

* Готов
* Добавляется
* Ошибка

При определении шарда для запроса хеш функция учитывает только готовые шарды для 
определения целевого шарда с данными. 

#### Добавление шардов:
1) В таблицу добавляются новые серверы со статусом "Добавляется".
2) Пересчитывается хеш для данных в старых таблицах.
3) Те записи, для которых хеш поменялся, копируются в новые шарды.
4) Статус новых шардов меняется на "Готов".
5) Со старых шардов удаляются лишние данные.


#### Удаление шардов
1) Пересчитывается хеш для данных в удаляемых шардах.
2) Данные переписываются на соответствующие неудаляемые шарды.
3) Шарды удаляются из базы `shards_info`.


Теоретически, если решардинг выполняется не из приложения, то можно избавиться от хранения состояния в базе статуса решардинга,
и просто хранить там лишь актуальные шарды.

Функционал подеплоен на heroku: https://limitless-tor-46576.herokuapp.com
